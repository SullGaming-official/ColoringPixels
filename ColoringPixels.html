<!DOCTYPE html>
<html>
<head>
  <title>ColoringPixels</title>
  <meta charset="UTF-8">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: sans-serif;
      background: #f0f0f0;
    }
    #blueBar {
      position: absolute;
      top: 0;
      left: 0;
      right: 180px;
      height: 50px;
      background: #3D2CDE;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 4px 10px;
      box-sizing: border-box;
      z-index: 2;
      border-bottom: 1px solid #ccc;
    }
    #sidebar {
      position: absolute;
      top: 0;
      right: 0;
      width: 180px;
      height: 100%;
      background: #3D2CDE;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px 4px;
      box-sizing: border-box;
      z-index: 1;
      overflow-y: auto;
    }
    #palette {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-bottom: 10px;
    }
    .color {
      width: 24px;
      height: 24px;
      margin: 2px;
      cursor: pointer;
      border: 1px solid #ccc;
      box-sizing: border-box;
    }
    .tool {
      margin: 4px;
      padding: 4px 8px;
      font-size: 14px;
      cursor: pointer;
      border-radius: 4px;
      width: 100px;
    }
    #zoomControl {
      margin-top: 8px;
      width: 60px;
    }
    canvas {
      position: absolute;
      top: 50px;
      left: 0;
      right: 180px;
      bottom: 0;
      display: block;
    }
  </style>
</head>
<body>
  <div id="blueBar">
    <p style="color: lightblue">ColoringPixels. By SullGaming.</p>
  </div>

  <div id="sidebar">
    <h1 style="color: lightblue">Colors</h1>
    <div id="palette"></div>

    <h1 style="color: lightblue">Tools</h1>
    <button class="tool" onclick="setTool('brush')">Brush</button>
    <button class="tool" onclick="setTool('eraser')">Eraser</button>
    <button class="tool" onclick="setTool('fill')">Fill</button>
    <button class="tool" onclick="undo()">Undo</button>
    <button class="tool" onclick="redo()">Redo</button>
    <button class="tool" onclick="wipeBoard()">Wipe Board</button>

    <h1 style="color: lightblue">
Save
Load
Delete </h1>
    <div id="saveSlots"></div>
<button class="tool" style="background:#c00; color:white;" onclick="showDeleteMenu()">Delete Save Files</button>

    <h1 style="color: lightblue; margin-top: 20px;">Zoom</h1>
<input id="zoomControl" type="number" min="0" value="10" oninput="resizeCanvas()" />
  </div>

  <canvas id="canvas"></canvas>
<script>
function showDeleteMenu() {
  const container = document.getElementById("deleteMenuContent");
  container.innerHTML = "";
  let foundAny = false;

  for (let i = 1; i <= 20; i++) {
    const key = "ColoringPixels_slot_" + i;
    if (localStorage.getItem(key)) {
      foundAny = true;
      const btn = document.createElement("button");
      btn.className = "tool";
      btn.textContent = "Delete Slot " + i;
      btn.onclick = () => deleteSlot(i);
      container.appendChild(btn);
    }
  }

  if (localStorage.getItem("ColoringPixels_autosave")) {
    foundAny = true;
    const autoBtn = document.createElement("button");
    autoBtn.className = "tool";
    autoBtn.textContent = "Delete Autosave";
    autoBtn.onclick = deleteAutosave;
    container.appendChild(autoBtn);
  }

  const cancelBtn = document.createElement("button");
  cancelBtn.className = "tool";
  cancelBtn.textContent = "Cancel";
  cancelBtn.onclick = hideDeleteMenu;
  container.appendChild(cancelBtn);

  if (foundAny) {
    document.getElementById("deleteMenu").style.display = "flex";
  } else {
    alert("No saved slots or autosave found to delete.");
  }
}

function hideDeleteMenu() {
  document.getElementById("deleteMenu").style.display = "none";
}

function deleteSlot(slot) {
  localStorage.removeItem("ColoringPixels_slot_" + slot);
  alert("Deleted Slot " + slot);
  hideDeleteMenu();
}

function deleteAutosave() {
  localStorage.removeItem("ColoringPixels_autosave");
  alert("Deleted Autosave");
  hideDeleteMenu();
}
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let size = 64;
let tileSize = 10;
let tool = 'brush';
let currentColor = "#000000";
let drawing = false;
let lastFill = null;
let lastX = null;
let lastY = null;
let grid = Array.from({ length: size }, () => Array(size).fill("#ffffff"));
let history = [];
let redoStack = [];

function resizeCanvas() {
  let zoomInput = parseInt(document.getElementById("zoomControl").value);
  tileSize = isNaN(zoomInput) ? 10 : Math.max(0, zoomInput); // allow 0 and up
  document.getElementById("zoomControl").value = tileSize;

  if (tileSize === 0) {
    canvas.width = 0;
    canvas.height = 0;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    return;
  }

  canvas.width = tileSize * size;
  canvas.height = window.innerHeight - 50;
  drawGrid();
  autosave();
}

function drawGrid() {
  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      ctx.fillStyle = grid[y][x];
      ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
      ctx.strokeStyle = "#ddd";
      ctx.strokeRect(x * tileSize, y * tileSize, tileSize, tileSize);
    }
  }
}

function saveState() {
  history.push(JSON.parse(JSON.stringify(grid)));
  if (history.length > 100) history.shift();
  redoStack = [];
}

function undo() {
  if (history.length === 0) return;
  redoStack.push(JSON.parse(JSON.stringify(grid)));
  grid = history.pop();
  drawGrid();
  autosave();
}

function redo() {
  if (redoStack.length === 0) return;
  history.push(JSON.parse(JSON.stringify(grid)));
  grid = redoStack.pop();
  drawGrid();
  autosave();
}

function wipeBoard() {
  if (!confirm("Clear the board?")) return;
  saveState();
  grid = Array.from({ length: size }, () => Array(size).fill("#ffffff"));
  drawGrid();
  autosave();
}

function drawLine(x0, y0, x1, y1, color) {
  let dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
  let sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;
  let err = dx - dy;
  while (true) {
    if (x0 >= 0 && y0 >= 0 && x0 < size && y0 < size) grid[y0][x0] = color;
    if (x0 === x1 && y0 === y1) break;
    let e2 = 2 * err;
    if (e2 > -dy) { err -= dy; x0 += sx; }
    if (e2 < dx) { err += dx; y0 += sy; }
  }
}

function floodFill(x, y, targetColor, replacementColor) {
  if (targetColor === replacementColor || grid[y][x] !== targetColor) return;
  grid[y][x] = replacementColor;
  if (x > 0) floodFill(x - 1, y, targetColor, replacementColor);
  if (x < size - 1) floodFill(x + 1, y, targetColor, replacementColor);
  if (y > 0) floodFill(x, y - 1, targetColor, replacementColor);
  if (y < size - 1) floodFill(x, y + 1, targetColor, replacementColor);
}

function handleDraw(e, isStart) {
  const rect = canvas.getBoundingClientRect();
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  const x = Math.floor((clientX - rect.left) / tileSize);
  const y = Math.floor((clientY - rect.top) / tileSize);
  if (x < 0 || y < 0 || x >= size || y >= size) return;

  if (isStart) {
    saveState();
    lastX = x;
    lastY = y;
  }

  if (tool === 'fill') {
    const key = x + "," + y;
    if (lastFill !== key) {
      floodFill(x, y, grid[y][x], currentColor);
      lastFill = key;
    }
  } else {
    lastFill = null;
    const color = (tool === 'brush') ? currentColor : "#ffffff";
    drawLine(lastX, lastY, x, y, color);
    lastX = x;
    lastY = y;
  }

  drawGrid();
  autosave();
}

// Input events
canvas.addEventListener("mousedown", e => { drawing = true; handleDraw(e, true); });
canvas.addEventListener("mousemove", e => { if (drawing) handleDraw(e, false); });
canvas.addEventListener("mouseup", () => { drawing = false; lastFill = null; lastX = null; lastY = null; });
canvas.addEventListener("mouseleave", () => { drawing = false; lastFill = null; lastX = null; lastY = null; });
canvas.addEventListener("touchstart", e => { drawing = true; handleDraw(e, true); });
canvas.addEventListener("touchmove", e => { if (drawing) handleDraw(e, false); });
canvas.addEventListener("touchend", () => {
  drawing = false;
  lastFill = null;
  lastX = null;
  lastY = null;
});

function setTool(name) {
  tool = name;
  autosave();
}

const paletteColors = [
  "#D20103", "#ff0000", "#FF8484", "#EC8E01", "#ffa500", "#FFDC9A", "#E2C44B", "#ffff00", "#FFFFAE",
  "#226308", "#008000", "#00ff00", "#2227C3", "#0000ff",  "#add8e6",  "#621079", "#800080", "#CC6CE7",
  "#DCADB6", "#ffc0cb", "#FFF0F3", "#A07D45", "#c8a165", "#EFD9B8", "#ffffff", "#d3d3d3", "#808080",
  "#5F5E5E", "#000000"
];

const palette = document.getElementById("palette");
paletteColors.forEach(color => {
  const swatch = document.createElement("div");
  swatch.className = "color";
  swatch.style.background = color;
  swatch.onclick = () => {
    currentColor = color;
    autosave();
  };
  palette.appendChild(swatch);
});

function autosave() {
  const data = {
    grid,
    tool,
    color: currentColor,
    zoom: tileSize
  };
  localStorage.setItem("ColoringPixels_autosave", JSON.stringify(data));
}

function loadAutosave() {
  const saved = localStorage.getItem("ColoringPixels_autosave");
  if (!saved) return;
  try {
    const data = JSON.parse(saved);
    grid = data.grid || grid;
    tool = data.tool || 'brush';
    currentColor = data.color || '#000000';
    if (data.zoom) {
      tileSize = data.zoom;
      document.getElementById("zoomControl").value = tileSize;
    }
  } catch (e) {
    console.warn("Autosave load failed:", e);
  }
}

function saveToSlot(slot) {
  const data = {
    grid,
    tool,
    color: currentColor,
    zoom: tileSize
  };
  localStorage.setItem("ColoringPixels_slot_" + slot, JSON.stringify(data));
  alert("Saved to Slot " + slot);
}

function loadFromSlot(slot) {
  const saved = localStorage.getItem("ColoringPixels_slot_" + slot);
  if (!saved) {
    alert("No save found in Slot " + slot);
    return;
  }
  try {
    saveState();
    const data = JSON.parse(saved);
    grid = data.grid || grid;
    tool = data.tool || 'brush';
    currentColor = data.color || '#000000';
    tileSize = data.zoom || tileSize;
    document.getElementById("zoomControl").value = tileSize;
    resizeCanvas();
    alert("Loaded Slot " + slot);
  } catch (e) {
    alert("Load failed: " + e.message);
  }
}

function deleteAllSaves() {
  if (!confirm("Delete all saved slots and autosave?")) return;
  for (let i = 1; i <= 20; i++) {
    localStorage.removeItem("ColoringPixels_slot_" + i);
  }
  localStorage.removeItem("ColoringPixels_autosave");
  alert("All save files deleted.");
}

const saveSlots = document.getElementById("saveSlots");
for (let i = 1; i <= 20; i++) {
  const saveBtn = document.createElement("button");
  saveBtn.className = "tool";
  saveBtn.textContent = "Save " + i;
  saveBtn.onclick = () => saveToSlot(i);
  saveSlots.appendChild(saveBtn);

  const loadBtn = document.createElement("button");
  loadBtn.className = "tool";
  loadBtn.textContent = "Load " + i;
  loadBtn.onclick = () => loadFromSlot(i);
  saveSlots.appendChild(loadBtn);
}

// Initialize on page load
window.onload = () => {
  loadAutosave();
  resizeCanvas();
};

// Resize canvas on window resize
window.onresize = resizeCanvas;
</script>
<div id="deleteMenu" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10; justify-content:center; align-items:center;">
  <div id="deleteMenuContent" style="background:white; padding:20px; border-radius:8px; display:flex; flex-direction:column; gap:10px; width:200px; max-height:80vh; overflow-y:auto;"></div>
</div>
</body>
</html>